Задание 1.
Написанное (битовое) решение
Плюсы:
Более быстрое выполнение
Минусы:
Плохая читаемость

Данное решение (через деление)
Плюсы:
Лёгкая читаемость
Минусы:
Более медленное выполнение

Задание 2.
Циклический буфер FIFO.

Первая реализация (task_2_1, RingBuffer)
FIFO в Python проще и эффективнее всего реализовать с помощью встроенной класса deque – двусвязного списка.

Цикличность обеспечивается также с помощью класса deque путём задания параметра maxlen – максимального размера очереди.
При достижении конца очереди новые данные будут перезаписывать самые старые,
что соответствует определению циклического буфера.

Плюсы реализации:
Вставка и удаление элемента в буфер за O(1).

Минусы реализации:
Нет возможности получить элемент буфера не извлекая его.
Невозможно изменить размер буфера.

Вторая реализация(task_2_2, AnotherRingBuffer)
Реализация через список вместо deque.

Цикличность обеспечивается указателем pointer, который хранит индекс самого старого элемента.

Плюсы:
Вставка элемента в буфер за O(1).
Возможность изменять размер буфера как в большую, так и в меньшую стороны.
Возможность получить элемент буфера без удаления.

Минусы:
Удаление элемента будет O(1) только в том случае, если извлекается самый правый элемент буфера,
в остальных случаях – O(N)

Третья реализация(task_2_3, YetAnotherRingBuffer)
Реализация через словарь. Аналогична по идеи второй реализации

Плюсы:
Вставка и удаление элемента в буфер за O(1).
Возможность изменять размер буфера как в большую, так и в меньшую стороны.
Возможность получить элемент буфера без удаления.
Минусы:
Изменение размера буфера происходит путём создания нового буфера.

Задание 3.
Реализуемый алгоритм – сортировка слиянием.
Ожидаемые лучший, средний и худшие случаи выполнения: O(N logN).

Доказательство реализации:

Функция merge_sort создаёт рекурсивное дерево. На каждом уровне количество элементов в подзадаче делится пополам.
Количество делений пополам числа n, производимых до тех пор, пока не будет получена единица, равно logN
Функция _merge производит слияние двух отсортированных списков. Слияние всех элементов на каждом уровне выполняется
за линейное время, каждый из n элементов участвует только в одной подзадаче на каждом уровне.
Так как глубина рекурсии составляет logN уровней, а каждый уровень обрабатывается за линейное время, то в наихудшем
случае время исполнения равно O(N logN).
